## Summary

This PR introduces an `ExecutionTrace` mechanism for structured tracing of agent graph execution, addressing the need for visibility into agent execution flows.

### Problem

Hive previously lacked a clear mechanism to trace and inspect agent executions. When an agent fails during execution or evolves its graph in response to runtime feedback, developers did not have a structured way to observe:
- Which nodes executed
- Node inputs and outputs
- Errors or retries
- Mutations applied to the agent graph

### Solution

Add an `ExecutionTrace` mechanism that:
1. Records node execution order, inputs, outputs, and errors
2. Captures edge traversals with conditions (sequential, fan-out, router-directed)
3. Logs retries with backoff timing and error messages
4. Supports graph mutation tracking for evolution loops
5. Has low overhead and is completely optional

### Changes

**New Files:**
- `core/framework/runtime/execution_trace.py` - Main ExecutionTrace implementation
  - `ExecutionTraceRecorder` - Thread-safe recorder for capturing trace events
  - `ExecutionTrace` - Pydantic model containing complete trace data
  - `NodeExecutionRecord`, `EdgeTraversalRecord`, `GraphMutationRecord` - Data models
  - `ExecutionTraceConfig` - Configuration for enabling/disabling trace features

- `core/tests/test_execution_trace.py` - 21 comprehensive tests

**Modified Files:**
- `core/framework/graph/executor.py` - Integration with GraphExecutor via optional `trace_recorder` parameter
- `core/framework/runtime/__init__.py` - Export new trace classes

### Usage Example

```python
from framework.runtime.execution_trace import (
    ExecutionTraceRecorder,
    ExecutionTraceConfig,
)

# Create recorder with optional config
config = ExecutionTraceConfig(
    enabled=True,
    capture_inputs=True,
    capture_outputs=True,
    max_input_output_size=10000,  # Truncate large values
)
recorder = ExecutionTraceRecorder(config=config)

# Inject into GraphExecutor
executor = GraphExecutor(..., trace_recorder=recorder)

# After execution, get the trace
trace = recorder.get_trace()
print(trace.model_dump_json(indent=2))

# Query specific data
failed_nodes = trace.get_failed_nodes()
retried_nodes = trace.get_retried_nodes()
```

### Features

- **Low overhead**: Append-only, minimal locking, efficient data structures
- **Optional**: Completely opt-in via `trace_recorder` parameter, no impact when not used
- **Structured**: Pydantic models for type safety and JSON serialization
- **Configurable**: Control what data is captured (inputs, outputs, errors, edges, mutations)
- **Value truncation**: Configurable max size for input/output values
- **Thread-safe**: Safe for use with parallel execution

### Testing

- 21 new tests covering all trace functionality
- All existing tests pass
- Thread-safety verified with concurrent test

Resolves #4031
